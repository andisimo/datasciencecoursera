rpois(5,2)
rpois(5,2)
set.seed(1)
rpois(5,2)
rbinom
str(rbinom)
summary(rbinom)
x <- c(1:10)
summary(x)
## Put comments here that give an overall description of what your
## functions do
## This function creates a special "matrix" object that can cache its inverse.
makeCacheMatrix <- function(x = matrix())
{
inverseMatrix <- NULL
#setMatrix sets the inverse and caches it
setMatrix <- function(newMatrix)
{
x <<- newMatrix
inverseMatrix <<- NULL
}
#getMatrix prints the inverse of matrix x
getMatrix <- function() x
#setInvert inverts the matrix and caches it
setInvert <- function(inverseArg)
{
inverseMatrix <<- inverseArg
}
getInvert < function() inverseMatrix
list(getMatrix = getMatrix, setMatrix = setMatrix, setInvert = setInvert, getInvert = getInvert)
}
## This function computes the inverse of the special "matrix" returned by makeCacheMatrix above.
#If the inverse has already been calculated (and the matrix has not changed), then the
#cachesolve should retrieve the inverse from the cache.
cacheSolve <- function(x, ...)
{
#get the inverse if it's cached somewhere in a parent environment
inverseMatrix <- x$getInvert
#check to see if it's NULL. If it is, then you do the work
if(!is.nULL(inverseMatrix))
{
message("getting cached data")
return inverseMatrix
}
#get - pass data from first function into a variable here
matrix <- x$getMatrix
#get the inverse of the matrix
inverse <- solve(matrix)
#set the inverse of the matrix. It will be cached.
x$setInvert(inverse)
inverse
}
## Put comments here that give an overall description of what your
## functions do
## This function creates a special "matrix" object that can cache its inverse.
makeCacheMatrix <- function(x = matrix())
{
inverseMatrix <- NULL
#setMatrix sets the inverse and caches it
setMatrix <- function(newMatrix)
{
x <<- newMatrix
inverseMatrix <<- NULL
}
#getMatrix prints the inverse of matrix x
getMatrix <- function() x
#setInvert inverts the matrix and caches it
setInvert <- function(inverseArg)
{
inverseMatrix <<- inverseArg
}
getInvert < function() inverseMatrix
list(getMatrix = getMatrix, setMatrix = setMatrix, setInvert = setInvert, getInvert = getInvert)
}
## This function computes the inverse of the special "matrix" returned by makeCacheMatrix above.
#If the inverse has already been calculated (and the matrix has not changed), then the
#cachesolve should retrieve the inverse from the cache.
cacheSolve <- function(x, ...)
{
#get the inverse if it's cached somewhere in a parent environment
inverseMatrix <- x$getInvert
#check to see if it's NULL. If it is, then you do the work
if(!is.nULL(inverseMatrix))
{
message("getting cached data")
return(inverseMatrix)
}
#get - pass data from first function into a variable here
matrix <- x$getMatrix
#get the inverse of the matrix
inverse <- solve(matrix)
#set the inverse of the matrix. It will be cached.
x$setInvert(inverse)
inverse
}
x <- matrix(nrow=2, ncol=3)
x
m <- matrix(1:6, nrow=2, ncol = 3)
m
makeCacheMatrix(m)
## Put comments here that give an overall description of what your
## functions do
## This function creates a special "matrix" object that can cache its inverse.
makeCacheMatrix <- function(x = matrix())
{
inverseMatrix <- NULL
#setMatrix sets the inverse and caches it
setMatrix <- function(newMatrix)
{
x <<- newMatrix
inverseMatrix <<- NULL
}
#getMatrix prints the inverse of matrix x
getMatrix <- function() x
#setInvert inverts the matrix and caches it
setInvert <- function(inverseArg)
{
inverseMatrix <<- inverseArg
}
getInvert <- function() inverseMatrix
list(getMatrix = getMatrix, setMatrix = setMatrix, setInvert = setInvert, getInvert = getInvert)
}
## This function computes the inverse of the special "matrix" returned by makeCacheMatrix above.
#If the inverse has already been calculated (and the matrix has not changed), then the
#cachesolve should retrieve the inverse from the cache.
cacheSolve <- function(x, ...)
{
#get the inverse if it's cached somewhere in a parent environment
inverseMatrix <- x$getInvert
#check to see if it's NULL. If it is, then you do the work
if(!is.nULL(inverseMatrix))
{
message("getting cached data")
return(inverseMatrix)
}
#get - pass data from first function into a variable here
matrix <- x$getMatrix
#get the inverse of the matrix
inverse <- solve(matrix)
#set the inverse of the matrix. It will be cached.
x$setInvert(inverse)
inverse
}
makeCacheMatrix(m)
arg -> makeCacheMatrix(m)
arg <- makeCacheMatrix(m)
cacheSolve(arg)
## Put comments here that give an overall description of what your
## functions do
## This function creates a special "matrix" object that can cache its inverse.
makeCacheMatrix <- function(x = matrix())
{
inverseMatrix <- NULL
#setMatrix sets the inverse and caches it
setMatrix <- function(newMatrix)
{
x <<- newMatrix
inverseMatrix <<- NULL
}
#getMatrix prints the inverse of matrix x
getMatrix <- function() x
#setInvert inverts the matrix and caches it
setInvert <- function(inverseArg)
{
inverseMatrix <<- inverseArg
}
getInvert <- function() inverseMatrix
list(getMatrix = getMatrix, setMatrix = setMatrix, setInvert = setInvert, getInvert = getInvert)
}
## This function computes the inverse of the special "matrix" returned by makeCacheMatrix above.
#If the inverse has already been calculated (and the matrix has not changed), then the
#cachesolve should retrieve the inverse from the cache.
cacheSolve <- function(x, ...)
{
#get the inverse if it's cached somewhere in a parent environment
inverseMatrix <- x$getInvert
#check to see if it's NULL. If it is, then you do the work
if(!is.NULL(inverseMatrix))
{
message("getting cached data")
return(inverseMatrix)
}
#get - pass data from first function into a variable here
matrix <- x$getMatrix
#get the inverse of the matrix
inverse <- solve(matrix)
#set the inverse of the matrix. It will be cached.
x$setInvert(inverse)
inverse
}
cacheSolve(arg)
## Put comments here that give an overall description of what your
## functions do
## This function creates a special "matrix" object that can cache its inverse.
makeCacheMatrix <- function(x = matrix())
{
inverseMatrix <- NULL
#setMatrix sets the inverse and caches it
setMatrix <- function(newMatrix)
{
x <<- newMatrix
inverseMatrix <<- NULL
}
#getMatrix prints the inverse of matrix x
getMatrix <- function() x
#setInvert inverts the matrix and caches it
setInvert <- function(inverseArg)
{
inverseMatrix <<- inverseArg
}
getInvert <- function() inverseMatrix
list(getMatrix = getMatrix, setMatrix = setMatrix, setInvert = setInvert, getInvert = getInvert)
}
## This function computes the inverse of the special "matrix" returned by makeCacheMatrix above.
#If the inverse has already been calculated (and the matrix has not changed), then the
#cachesolve should retrieve the inverse from the cache.
cacheSolve <- function(x, ...)
{
#get the inverse if it's cached somewhere in a parent environment
inverseMatrix <- x$getInvert
#check to see if it's NULL. If it is, then you do the work
if(!is.null(inverseMatrix))
{
message("getting cached data")
return(inverseMatrix)
}
#get - pass data from first function into a variable here
matrix <- x$getMatrix
#get the inverse of the matrix
inverse <- solve(matrix)
#set the inverse of the matrix. It will be cached.
x$setInvert(inverse)
inverse
}
cacheSolve(arg)
s <- cacheSolve(arg)
s
str(s)
summary(s)
str(s)
type(s)
class(s)
debug(cacheSolve(arg))
debug(cacheSolve())
debug(cacheSolve(arg))
cacheSolve(arg)
debug(cacheSolve)
cacheSolve(arg)
inverseMatrix
cacheSolve(arg$getInvert())
}
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinv <- function(inverse) inv <<- inverse
getinv <- function() inv
list(set = set, get = get, setinv = setinv, getinv = getinv)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x$getinv()
if(!is.null(inv)) {
message("getting cached data")
return(inv)
}
data <- x$get()
inv <- solve(data, ...)
x$setinv(inv)
inv
}
m <- matrix(1:6, nrow=2, ncol = 3)
arg <- makeCacheMatrix(m)
arg
cacheSolve(arg)
arg$get()
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinv <- function(inverse) inv <<- inverse
getinv <- function() inv
list(set = set, get = get, setinv = setinv, getinv = getinv)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x$getinv()
if(!is.null(inv)) {
message("getting cached data")
return(inv)
}
data <- x$get()
inv <- solve(data)
x$setinv(inv)
inv
}
cacheSolve(arg)
solve(arg)
m <- matrix(1:9, nrow = 3, ncol = 3)
arg <- makeCacheMatrix(m)
cacheSOlve(arg)
cacheSolve(arg)
solve(arg)
class(arg)
class(m)
m
solve(m)
m <- matrix(1:12, ncol=3, nrow=4)
m
solve(m)
## Put comments here that give an overall description of what your
## functions do
## This function creates a special "matrix" object that can cache its inverse.
makeCacheMatrix <- function(x = matrix())
{
inverseMatrix <- NULL
#setMatrix sets the inverse and caches it
setMatrix <- function(newMatrix)
{
x <<- newMatrix
inverseMatrix <<- NULL
}
#getMatrix prints the inverse of matrix x
getMatrix <- function() x
#setInvert inverts the matrix and caches it
setInvert <- function(inverseArg)
{
inverseMatrix <<- inverseArg
}
getInvert <- function() inverseMatrix
list(getMatrix = getMatrix, setMatrix = setMatrix, setInvert = setInvert, getInvert = getInvert)
}
## This function computes the inverse of the special "matrix" returned by makeCacheMatrix above.
#If the inverse has already been calculated (and the matrix has not changed), then the
#cachesolve should retrieve the inverse from the cache.
cacheSolve <- function(x, ...)
{
#get the inverse if it's cached somewhere in a parent environment
inverseMatrix <- x$getInvert
#check to see if it's NULL. If it is, then you do the work
if(!is.null(inverseMatrix))
{
message("getting cached data")
return(inverseMatrix)
}
#get - pass data from first function into a variable here
matrix <- x$getMatrix
#get the inverse of the matrix
inverse <- solve(matrix)
#set the inverse of the matrix. It will be cached.
x$setInvert(inverse)
inverse
}
solve
## Put comments here that give an overall description of what your
## functions do
## This function creates a special "matrix" object that can cache its inverse.
makeCacheMatrix <- function(x = matrix())
{
inverseMatrix <- NULL
#setMatrix sets the inverse and caches it
setMatrix <- function(newMatrix)
{
x <<- newMatrix
inverseMatrix <<- NULL
}
#getMatrix prints the inverse of matrix x
getMatrix <- function() x
#setInvert inverts the matrix and caches it
setInvert <- function(inverseArg)
{
inverseMatrix <<- inverseArg
}
getInvert <- function() inverseMatrix
list(getMatrix = getMatrix, setMatrix = setMatrix, setInvert = setInvert, getInvert = getInvert)
}
## This function computes the inverse of the special "matrix" returned by makeCacheMatrix above.
#If the inverse has already been calculated (and the matrix has not changed), then the
#cachesolve should retrieve the inverse from the cache.
cacheSolve <- function(x, ...)
{
#get the inverse if it's cached somewhere in a parent environment
inverseMatrix <- x$getInvert
#check to see if it's NULL. If it is, then you do the work
if(!is.null(inverseMatrix))
{
message("getting cached data")
return(inverseMatrix)
}
#get - pass data from first function into a variable here
matrix <- x$getMatrix
#get the inverse of the matrix
inverse <- solve(matrix)
#set the inverse of the matrix. It will be cached.
x$setInvert(inverse)
inverse
}
makeCacheMatrix(m)
cacheSolve(makeCacheMatrix(m))
debug(cacheSolve)
cacheSolve(makeCacheMatrix(m))
debug(makeCacheMatrix)
debug(cacheSolve)
cacheSolve(makeCacheMatrix(m))
rm(list=ls())
getwd()
setwd("Git/datasciencecoursera/RProgrammingCourse/Programming Assignment 4"
)
getwd()
read("hospital-data.csv")
outcome <- read.csv("hospital-data.csv")
outcome <- read.csv("hospital-data.csv", colClasses = "character")
head(outcome)
ncol(outcome)
nrow(outcome)
names(outcome)
outcome <- read.csv("outcome-of-care-measures.csv", colClasses = "character")
head(outcome)
outcome[,11] <- as.numeric(outcome[,11])
hist(outcome[,11])
outcome$Hospital.30.Day.Death..Mortality..Rates.from.Heart.Attack <- as.numeric(outcome$Hospital.30.Day.Death..Mortality..Rates.from.Heart.Attack)
hist(outcome$Hospital.30.Day.Readmission.Rates.from.Heart.Attack)
outcome[,11]
colnames(outcome)
thisfile <- read.csv("outcome-of-care-measures.csv", colClasses = "character")
source("best.R")
class(thisfile)
head(thisfile)
colnames(thisfile)
source("best.R")
best("CA", "hen")
debug(best)
best("CA", "hen")
source("best.R")
best("CA", "hen")
source("best.R")
best("CA", "hen")
debug(best)
best("CA", "hen")
healthdata <- read.csv(paste(getwd(), "/outcome-of-care-measures.csv", sep = ""))
best("CA", "hen")
best("CA", "hen")
source("best.R")
best("CA", "hen")
debug(best)
best("CA", "hen")
source("best.R")
debug(best)
best("CA", "hen")
source("best.R")
debug(best)
best("CA", "hen")
best("CA", "heart attack")
source("best.R")
best("CA", "heart attack")
source("best.R")
best("CA", "heart attack")
best("CA", "heart attack")
best("CA", "heart attack")
best("CA", "heart attack")
best(state = "CA", outcome = "heart attack")
source("best.R")
best(state = "CA", outcome = "heart attack")
debug(best)
best(state = "CA", outcome = "heart attack")
healthdata[order(healthdata$outcomecolumn)]
outcomecolumn <- "Hospital.30.Day.Death..Mortality..Rates.from.Heart.Attack"
healthdata[order(healthdata$outcomecolumn)]
healthdata$outcomecolumn
healthdata$myname
t <- paste("healthdata$", outcomecolumn, sep = "")
t
healthdata[order(t)]
healthdata[order(paste("healthdata$", outcomecolumn, sep = ""))]
source("best.R")
best(state = "CA", outcome = "heart attack")
source("best.R")
best(state = "CA", outcome = "heart attack")
d <- gl(3,10)
d
sorted <- healthdata[order(paste("healthdata$", outcomecolumn, sep = ""))]
splitted <- split(sortedData, sortedData[,7])
splitted <- split(sorted, sorted[,7])
head(sorted)
sorted
head(sorted)
head(healthdata)
colnames(sorted)
sorted <- healthdata[order(paste("healthdata$", outcomecolumn, sep = ""))]
colnames(sorted)
source(best.R)
source("best.R")
best("CA", "heart attack")
source("best.R")
best("CA", "heart attack")
healthdatasorted <- healthdata[order(paste("healthdata$", "Hospital.30.Day.Death..Mortality..Rates.from.Heart.Attack", sep = ""))]
colnames(healthdatasorted)
colnames(healthdata)
